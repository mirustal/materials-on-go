##  Модель  OSI 
	1) Физический уровень (передача сигналов)
	2) Канальный уровень (проверка и подпись сигнала) Frame 
	3) Сетевой уровень (Запрос и передачи данных) Packet 
	4) Транспортный уровень (Протокол передачи данных) 
		 У нас появляется порт, сокет, и байты/биты записываются в сокет (это просто файл для ОС),  и вот в net poller’e гоняется, опрашивает epoll, epoll смотрит таблицу файловых дескриптеров, на предмет полученных новых байтов, с помощью флага определяется, пришли ли новые данные или нет.   Затем, горутина получив данные, она с net poller’a попадает в глобальную очередь, потом попадает на локальную, затем попадает на машину, и уже на машине, эта горутина вычитывает данные из сокета, а это уже обычная синхронная операция…
	5) Сеансоввый (Тип подключения для передачи данных) 
	6) Представительный(Метод обработки данных)
	7) Прикладной

![[Pasted image 20240419083612.png]]
## Runtime 
[(3) Антон Сергеев, «Go под капотом» - YouTube](https://www.youtube.com/watch?v=rloqQY9CT8I&ab_channel=KolesaGroup)
## Планировщик(Scheduling )
	стуктура планировщика; у него есть глобальный пул запуск горутин, есть gmp и очередь работающих горутин
	machine tread- абстракция над тредом ОС

	### Планировщик ОС
Планировщик ОС отвечает за то, чтобы ядра не простраивали, если есть потоки, которые могут выполняться.

Выполнение инструкций
	Счетчик команд, также(instruction pointer)  позволяет потоку отслеживать следующую команду для выполнения. В большинстве процессоров IP указывает на следующую инструкцию, а не на текущую 

Состояния потоков
	1. Ожидание - поток остановлен и ожидает продолжения, простоходит из за ожидания аппаатного обеспечения, ОС или вызовов синхронизаций
	2. Готовность - Поток требует времени на ядре, для того чтобы он мог выполнять назначенные ему машинные инструкции 
	3. Выполнение - потом размещен на ядре и выполняет машинные инструкции 
Типы работ:
	1. CPU-Bound - Работа, которая не создает ситуацию, когда поток может быть переведен в состояние ожидания, работа, которая постояно делает расчеты 
	2. IO-Bound - работа, которая заставляет потоки переходить в состояние ожидания. Это работа, которая заключается в запросе доступа к ресурсу
Переключатель контекста:
	1. Вытесняющие (preemptive) алгоритмы - способы планирования потоков, в которых решения о переключении процессора с выполнения одного потока на выполнения другого потока принимается ОС
	2. Невытесняющие(non-preemptive)(в го невная-кооперативная) алгоритмы основаны на том, что активному потоку позволяется выполняться, пока он сам, по собственной инициативе, не отдаст управления ОС для того, чтобы она выбрала другой, готовый к выполнению поток

Принятия решений для планировщика происходит в руках runtime в GO
	P, М, G
		-P (processor) - логический процессор. Условный контекст, который связывает поток операционной системы (М) и очередь горутин. Количество горутин привязанных к процессору не ограничено. Количество процессоров берется из значения переменной среды GOMAXPROCS и равно количество логических ядер процессора
		-M  (machine thread)  - поток операционной системы. Он закреплен за Р и имеет с ним отношения один к одному.
		-G( goroutine) - горутина
	Goroutine
		 Горутина это по сути Корутина, но в го, можно думать о ней как о потоках уровня прилоежения. Они включаются. и выключаются взависимости от контекста потока. Программе выделяется начальная горутина 
	Состояние потоков: 
		-Waiting: Горутина остановлена и ожидает чего-то, чтобы продолжить работу, возможные причины: ожидание ОС(системные вызовы) или вызорвы синхронизации(атомарные операции/мьютексты) такие задержки это основные причины низкой производительности
		-Runnable: Горутине нужно время на М, чтобы она могла выполнять назначенные инструкции, если горутин много то они вынуждены ждать дольше, чтобы получить это время. Чем больше горутин, чем меньшее количество индвидуального времени. Так же является причиной знизкой производительности.
		-Running: Горутина была помещена на М и выполняет свои инструкции
	Переключатения контекста (Context Switching)
		Более легковесный чем переключатель OS
	GRQ, LRQ
		В планировщике Go есть разные очереди выполнения
		Глобальная очередь (global Run Queue) и локальная очередь выполнения (Local run Queue), в ней всего 256 элементов. Каждому P присваивается LRQ, которая управляет горутина, назначенными для выполнения на Р. Горутины по очереди включаются и выключаются в зависимости от контекста М, назначенному этому Р. GRQ же предназначен для горутин, которые еще не были назачены для какого либо Р. СУществует процесс перемещния из GRQ в LRQ 
	Ограничения планировщика GO:
		-Очередь FIFO ( отсутствие контроля над приоритетами задач)
		-Кооперативная многозадачность является причиной, что нет гарантии времени выполнения горутины
		-Горутины могут переключаться между потоками, что снижает эффективность кэшей
	Кража работы:
			Если процессор простаивает то он украдет работу у другого процессора или у глобальной очереди или у нетпуллера( ровно половину ) 
			Время на проверку локальной очереди состовляет 1/61 от времени работы
			колиечство сворованных задач равна (количество задач в очереди / количество процессов), но в случае если очереди пусты, тогда мы воруем половину у рандомного процесса

goshec
## Сетевой поллер (netpoller)
		Отвечает за обработку системнх вызовов, такие как сететвой ввод-вывод, если горутина ожидает завершения сетевого запроса, тогда она будет добавлена в сетевой полер, если глобальная очередь пустая тогда она будет опрашивать сеть, если в сетевом полере есть работающая горутина то ей к ней добавится своя локальная очередь




## Что такоаае срез?
Срез - это структура данных, описывающая непрерывную часть массива

Срез стоит из {
	length int
	ZeroElement \*type element
}


## Что такое строка? 
- Неизменяемый срез байтов
- это структура с полем len и указатеем на первый элемент
Если мы итерируемся по строке, каждая итерация это указатель на 







## Интерфейсы

Абстрактные типы данные
Хранить типа объекта и конкретную информацию о типе объекта 

Проверка типа интерфейса можно сделать через тайпСерч, рефлексия 

Типы у которых не может существовать собственных значений 
К примеру числа
Над любыми( с исключениями) совершать арифметические действия, можно объявить абстрактный тип "число", разными реализациями которого будет натуральные, целые, рациональные числа..

Интерфейс это абстрактный тип данных

Идиоматика: 

1. Чем меньше методов тем лучше
2. Если у интерфейса один метод то принято называть интерфейс существительным

пустой интерфейс - это интерфейс, которому соотвествует все что угодно (обязательно нужно обработать все типы данные, которые планируешь поддерживать)


## Хэш-таблица
Преобразуем ключ с помощью хэш функции на выходе получаем число(то есть айдишник нашей ассоциативной таблицы) 

Коллизия - это случай когда после преобразования мы получаем точно такой же ID
	1. Метод открытой адресации - сохранение в следующую свободную ячейку
	2. Пробирование - использование хэш функции к полученному значению до момента пока не появится свободного значнеия 
	3. Метод цепочек - создание списка в ячейке 

Хорошая хэш функция
1) Детерминизм 
2) Равномерность
3) Эфективность должна быть константное
4) Ограниченность 0 < значения после хэш функции < размер таблицы

Как работает мапа в ГО
Абстрактная структурная  данных

## Структура мапы в GO
Мапа состоит из header, который хранит общую инфу
Header:
	1.размер - количество элементов, 
	2. количество бакетов( хранится в логарифме в целях экономии)
	3. Указатель на  бакеты LOB (low order bts)
	4. хэш сид  
Указатель на бакеты: после хэширования ключа происходит побитовое вычисления остатка от деления (то есть число в бинарном виде по количество бакетов логарифма )

Как выглядят бакеты: 
8 слотов для HOB hash,  если ключ есть в текущем бакете то мы берием все ключи с искомым, если его нет то значения точно нет в текущей мапе
Key: ключ
value:   значение

Переполнение бакета создаетс новый бакет, в изначальный бакет  добавилась ссылка на новый бакет 
(эвакуация данных?)

Перебор мапы происходит случайно
В fmt происходит сортировка мапы 

Map insert, remove, lookup
Все операции должны иметь константное время


ВСТАВКА В НЕ ИНИЦИАЛИЗИРОВАННУЮ МАПУ ЭТО ПАНИКА!!!!


## Каналы в го
Каналы хранятся в куче 
	Канал представляет собой структуру которая содержи
	1. количество в буфере 
	2. ссылка на буфер 
	3. указатели на спящие записи/чтнение горутины
	4. Мьютекс

У не буферризированного канала нет буфера и данные с одного стека передается в стек другой 

каналы безопасны за счет мьютексов (и анатомиках)

Каналы Хранят данные в буфере(кольцеризированном)

Передачи данных 

Блокировка горутин. - очереди 

- Запись и чтения с неициализированного канала блокирует горутину!!
- запись в закрытый канал возывает панику
- чтение из закрытого канала дает нулевое значение

## Планировщик GO


Структура планировщика:
Есть

Планировщик работает на потоках ОС, контекст постоянно переключается так чтобы ни один поток не простаивал

Многозадачность 
	1. Кооперативная - если горутина выполняется то она " подсказывает" когда ее можно снять
	2.Вытесняющая - сам решает, когда его можно вытеснуть


Приоритетное планирование, выдавать каким то потокам приоритеты 
## Горутина 
Аналог корутины  


Отличие от обычного потока - это легковесность
У горутины динамический стек и она менеджментся рантаймом го 

## sync.Pool 
Реализация паттерна обжект пул и хранит в себе фиксированное количество объектов (ну куче)
## sync.Cond
Реакция на какое-то действие
### Мьютексы  
Просто какая то атомик операция которою можно проверит, горутина ставится в ожидание и ждет очереди на мьютекс

### Спинлок 
Бесконечный цикл, можно использовать когда мы точно знаем, что не будет никаких систем локов и точно знаем, что из него можем выйти

### Проблемы сихронизации

Data race - Одновременное изменение одного места памяти разными потоками (нужно примитивы синхрнизации)
Есть флаг при компиляции --race (race detector), он никогда не ошибается

Race condition - dead lock - все горутины заблокированы 


### Атомарные операции
compare 
swap


### Контекст

Интерфейс в котором есть методы которые позволяют отслеживать закрытие или записать значение

Есть пустые контесты

Есть  отмены при вызове контекста, канал закрывает и все получают сигнал об этом

withTimeod - через сколько умрет

withTimeLock- кодка умрет

### ООП В ГО
Классические постулаты 
Полимофирзм - реализовано через интерфейс, все те кто могут говорить, они будут говорить


Наследование - его нет, но можно заменить композицией(Встраивание структуры в структуру)


Инкапсуляция -  инкапсуляция это заключение данных и методов в единую сущность 
маленькая/большая буква в GO 


## SOLID
S - **Single Responsibility Principle** гласит, что класс или модуль должен иметь только одну причину для изменения. Корочег говоря - каждый класс или функция должны решать лишь одну задачу, не более. Если у вас есть функция или класс, который меняется по нескольким причинам, это первый звоночек, что вы нарушаете SRP

P - **Open/closed Principle** - программные сущности (классы, модули, функции и т.д.) должны быть открыты для расширения, но закрыты для изменения. Нужно свой код таким образом, чтобы для добавления новой функциональности не требовалось менять существующий код. Соблюдение этого уменьшает вероятность возникновения багов, т.к вам не нужно трогать уже работающий код

L - **LSP** гласит, что объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности работы программы. Это звучит как-то непонятно, но на самом деле всё просто: если у вас есть класс-родитель и класс-потомок, то любой код, который использует родительский класс, должен работать так же хорошо и с объектами дочернего класса.

I - **ISP** утверждает, что юзеры не должны быть вынуждены зависеть от интерфейсов, которые они не используют. Это означает, что вместо одного наполненного интерфейса лучше иметь несколько тонких и специализированных

D - **DIP** гласит, что высокоуровневые модули не должны зависеть от низкоуровневых модулей. Оба типа модулей должны зависеть от абстракций.


## DRY

Каждый кусочек знаний в системе должен иметь единственное, недвусмысленное, авторитетное представление в рамках системы. Проще говоря, надо избегать повторения одного и того же кода в разных частях вашей программы. Когда логика дублируется, любое изменение в ней требует обновления во всех местах, где она встречается.



## Память

Размер стека 2КБ
### Аллокация 
Процессы не имеют прямого доступа к физической памяти
Фрагментация памяти - заполнения фрагмента памяти с частыми пропусками
Если runtime Go нуждается в памяти, он запрашивает его у системы, к примеру на Linux это 64МБ

Арена разделена на страницы по 8 Кб, а страницы объедины в спаны размеров от 8 до 80КБ, 
Каждый спан выступает в роли пула памяти для объектов класса размера (всего 67 классов)

Эмпирическая оценка фрагментации памяти может быть вычислена с помощью формулы 
$Fragmentatin = \frac{Sys - HeapReleased}{HeadInUse}$ 
Sys- общее количество памяти, HeapREleased- объем, который был возвращен ОС из кучи
HeadInUse - объем, который используется для хранения

В go у потока есть cache, в начале просим у память у него, если в нем есть то он просит новую арену(решение проблемы contention)
### Garbage collector
Если доступна всего одна машина GB будет отрабатывать каждый 4 раз

Испольуется трехцевтный mark-and-sweep алгоритмы Дейстры и Лемпорта, используется он из за хорошего параллеливания по ядрам

mark and sweep - 
До начала разметки есть граф неразмеченных объектов произвольного размера:
шаг 1. Покрасили объект 1. Пул объектов, которые связаны с объектом 1 — 3 и 4:
Разметка — шаг 2. Покрасили объекты 3 и 4. Пул объектов, связанных с окрашенной частью графа — 6:
Разметка — шаг 3. Покрасили объект 6. Объектов, связанных с окрашенной частью графа, не осталось. Пришло время чистить мусор:
Объекты 2 и 7 недостижимы, их можно переработать:

Stop-The-World - 

Этот подход работает и в Golang: все объекты в стадии разметки красятся в чёрный, серый или белый цвет:

- белый — потенциальный мусор, ещё не затронутые алгоритмом объекты;
    
- серый — объекты «на рассмотрении»;
    
- чёрный — активные объекты.
    

Изначально все объекты в куче и на стеке окрашены в белый.

В целом, алгоритм можно представить циклом из нескольких шагов:

1. Покрасить все корневые объекты (стек и глобальные переменные) в серый.
    
2. Выбрать серый объект из набора серых объектов и пометить его как чёрный.
    
3. Все объекты, на которые указывает чёрный объект, пометить серым. Это гарантирует, что сам объект и объекты, на которые он ссылается, не будут выброшены в мусор.
    
4. Если в графе остались серые объекты, вернуться к шагу 2.


В распоряжении GC есть пул воркеров(горутин) Используется на 25%, но когда он еще работает, но уже превышен размер heap target size то выделяется все 50% мощности CPU 

За запуск сборки мусра отвечает GC Pacer, запускается, когда размер хипа вырастает на определенный процент записанный в GOGC
Если используется всего одна машина( 1 поток) то GC встанет в очередь и каждый 4 раз будет вызываться 

В стек записываются:
Слайсы размером до 64КБ
массив до 10 МБ хранится в стеке

Для правильности описания типа чтобы GB потреблял меньше при линковке нужно 
по порядку размера упорядочить размеры данных, а ссылочные данные послать в самый вверх


### Escape Analysis

### Scavenger golang

Элемент рантайма, который отвественный за возврат оперативной памяти операционной системе

В go никогда не используется munmap, потому что он считается дорогим, поэтому рантайм подсказывает ОС можно ли чистить область памяти используя madvice, в этом и заключается задача scavenger 

Работаа CPU не преывашает 1% 



# Брокеры сообщений

## Виды сообщений

1) Диалог - Кто-то N обращается к кому-то Y и высказывает ему мнение, ждет ответа или обратную связь (request-resonse)
2) Или тоже самое только N транислирует сообщения для Y, но не ждет ничего в ответ (One-Way)
3) Кто-то N отправляет сообщения X, а X передает сообщения своим знакомым, при этом N не знает кому передает сообщения X (publish-subscribe)
4) Или N записывает сообщения в ящик, а те кто имеют к нему доступ могут заглядывать в ящик и забирать по одной карточке, одно сообщение-один получатель(Point)

## Паттерны обмена информации

- Request-Response (Запрос-Ответ);
- One-Way (Односторонний) или Fire and Forget (Отправил и забыл);
- Publish-Subscribe (Публикация-Подписка) или сокращённо Pub-Sub;
- Point-to-Point (Точка-Точка).

### Преймущества Request-Response и One-way

Программы общаются напрямую синхронно друг с другом. У такого взаимодействия есть особенности:

- отправителю нужно знать адрес получателя;
- получатель должен быть доступен в момент вызова;
- из-за сбоя отправитель может никогда не дождаться ответа;
- отправитель блокируется в ожидании ответа.
### Преймущества Publish-Subscribe и Point-to-Point

В паттернах Pub-Sub и Point-to-Point происходит асинхронное общение через посредника. При реализации таких паттернов у программ появляются возможности:

- осуществлять асинхронный обмен данными (отправитель не блокируется);
- отделять отправителя от получателя (отправитель ничего не знает о получателе);
- выполнять отложенную обработку сообщений. Получателю не нужно быть постоянно активным, можно читать сообщения в удобное время;
- делегировать ответственность за маршрутизацию и доставку сообщений третьей стороне;
- легко интегрироваться с системами, использующими различные платформы, языки и протоколы связи.

## Гарантии доставки

1) At most once (Отправил и забыл) - Большая часть сообщений доходит до получателя, но часть теряется из-за сбоев.
2) At least once (Хотя бы один раз) - Чтобы все данные достигли цели, могут предприниматься повторные отправки. Хотя бы одна попытка будет успешной. В таком случае сообщения не теряются, но могут дублироваться.
3) Exactly once (Строго один раз) - максимальная гарантия доставки. Сообщения никогда не теряются и не дублируются, каждое доставляется ровно один раз.
4) Очередь и Топик - Брокер, реализующий шаблон Point-to-Point, ассоциируется с термином Queue (Очередь). Сообщения отправителя попадают в очередь, получатель извлекает сообщения из очереди. После извлечения сообщение становится больше никому не доступными. Данные в очереди хранятся, пока они не будут прочитаны или не истечёт срок их действия. В Pub-Sub ассоциируется с темой, топиком (Topic). Сообщения попадают в топик. Система распределяет каждое сообщение между всеми подписчиками топика (Broadcast, вещание). Сообщения могут храниться в топике, до тех пор, пока это необходимо для распространения данных между всеми подписчиками.



```

func mergeChan (cs ...<-chan int) <-chan int {
	out := make(chan int)
	 wg := sync.WaitGroup{}
	output := func(c <- chan int) {
		for n := range c {
		out <- n
		}
		wg.Done()
	}
	wg.Add(len(cs))
	for c:= range cs {
		go output(c)
	}

	go func() {
	wg.Wait()
	close(out)
	}()
	return out
}

```
# Задачи
### Задачи по программированию на Go

#### 16. Реализуйте стек (LIFO)

Реализуйте структуру стека с функциональностью `pop`, `append` и `print top`.

**Решение**

Стек можно реализовать с помощью объекта среза.

```
package main
import "fmt"
func main() {
// Создание стека
var stack []string
// Добавление элементов
stack = append(stack, "world!")
stack = append(stack, "Hello ")
for len(stack) > 0 {
        // Print top
        n := len(stack) - 1
        fmt.Print(stack[n])
        // Pop
        stack = stack[:n]
}
// Output: Hello world!
}
```

Сначала мы используем встроенную функцию `append()` для реализации поведения присоединения. Далее с помощью `len(stack)-1` мы извлекаем верхушку стека и выводим ее на экран.

Для `pop` мы устанавливаем в качестве новой длины стека позицию выведенного верхнего значения, `len(stack)-1`.

#### 17. Выведите все пермутации символов среза или строки

Реализуйте функцию `perm()`, принимающую срез или строку и выводящую все возможные комбинации его (ее) символов.

**Решение**

```
package main
import "fmt"
// Perm вызвает f с каждой пермутацией a.
func Perm(a []rune, f func([]rune)) {
        perm(a, f, 0)
}
// Пермутируем значения в индексе i на len(a)-1.
func perm(a []rune, f func([]rune), i int) {
        if i > len(a) {
                f(a)
                return
        }
        perm(a, f, i+1)
        for j := i + 1; j < len(a); j++ {
                a[i], a[j] = a[j], a[i]
                perm(a, f, i+1)
                a[i], a[j] = a[j], a[i]
        }
}
func main() {
Perm([]rune("abc"), func(a []rune) {
        fmt.Println(string(a))
})
}
```

Мы используем типы `rune` для обработки и срезов, и строк. `Runes` являются кодовыми точками из Unicode, а значит могут парсить строки и срезы одинаково.

#### 18. Поменяйте местами значения переменных без использования промежуточной переменной

Реализуйте `swap()`, обменивающую значения двух переменных, не используя третью переменную.

**Решение**

Во многих других языках над этой задачей придется подумать, в Go же реализовать ее просто.

```
package main
import "fmt"
func main() {
   fmt.Println(swap())
}
func swap() []int {
      a, b := 15, 10
   b, a = a, b
   return []int{a, b}
}
```

Достаточно просто включить инструкцию `b, a = a, b`, на чьи данные будет ссылаться переменная, не взаимодействуя ни с одним из ее значений.

#### 19. Реализуйте поведение min и max

Реализуйте функции `Min(x, y int)` и `Max(x, y int)`, получающие два целых числа и возвращающих меньшее или большее значение соответственно.

**Решение**

По умолчанию Go поддерживает `min` и `max` только для чисел с плавающей запятой, используя для этого `math.min` и `math.max`. Вам потребуется создать собственные реализации, чтобы то же самое можно было проделать для целых чисел.

```
package main
import "fmt"
// Min возвращает меньшее из x или y.
func Min(x, y int) int {
        if x > y {
                return y
        }
        return x
}
// Max возвращает большее из x или y.
func Max(x, y int) int {
        if x < y {
                return y
        }
        return x
}
func main() { 
    fmt.Println(Min(5,10))
    fmt.Println(Max(5,10))
}
```

#### 20. Переверните порядок элементов в срезе

Реализуйте функцию `reverse`, получающую срез целых чисел и разворачивающую его без использования временного среза.

**Решение**

```
package main
import "fmt"
func reverse(sw []int) {
        for a, b := 0, len(sw)-1; a < b; a, b = a+1, b-1 {
                sw[a], sw[b] = sw[b], sw[a]
        } 
}
func main() { 
    x := []int{3, 2, 1} 
    reverse(x)
    fmt.Println(x)
}
```

Цикл `for` меняет местами значения каждого элемента среза. Значения будут следовать слева направо, и в итоге все элементы будут развернуты.

#### 21. Как легче всего проверить срез на пустоту?

Создайте программу, проверяющую срез на пустоту. Найдите самое простое решение.

**Решение**

Легче всего проверить срез на пустоту с помощью встроенной функции `len()`, которая возвращает длину среза. Если `len(slice) == 0`, значит срез пуст.

Например:

```
package main
import "fmt"
func main() {
  r := [3]int{1, 2, 3}
  if len(r) == 0 {
    fmt.Println("Empty!")
  } else {
    fmt.Println("Not Empty!")
  }
}
```

#### 22. Отформатируйте строку без ее вывода

Найдите самый простой способ отформатировать строку с переменными, не выводя значение. 

**Решение**

Легче всего это сделать с помощью `fmt.Sprintf()`, которая возвращает строку, не выводя ее на экран.

Например:

```
package main

import "fmt"

func main() {
  s := fmt.Sprintf("Size: %d MB.", 85)
  fmt.Println(s)
}
```

### Вопросы, касающиеся конкурентности

#### 23. Объясните разницу между конкурентностью и параллельностью в Go

Конкурентность  —  это, когда программа может работать с несколькими задачами одновременно, а параллельность  —  это, когда программа может одновременно выполнять несколько задач на нескольких процессорах.

Другими словами, конкурентность  —  это свойство программы, которое позволяет нескольким задачам быть запущенными одновременно, но не обязательно одновременно выполняться. Параллельность же относится к свойствам среды выполнения, когда две или более задач выполняются одновременно.

Это значит, что посредством параллельности можно получить конкурентное поведение, но на этом ее возможности не ограничиваются.

Основными инструментами для реализации конкурентности в Go являются горутины и каналы. Горутины  —  это конкурентные легковесные потоки, а каналы позволяют им взаимодействовать в процессе выполнения.

#### 24. Merge sort 

Реализуйте конкурентное решение `merge sort` (сортировка слиянием), используя горутины и каналы.

В качестве опорной точки можно взять эту последовательную реализацию:

```
package main
import "fmt"
func Merge(left, right [] int) [] int{
  merged := make([] int, 0, len(left) + len(right))
  for len(left) > 0 || len(right) > 0{
    if len(left) == 0 {
      return append(merged,right...)
    }else if len(right) == 0 {
      return append(merged,left...)
    }else if left[0] < right[0] {
      merged = append(merged, left[0])
      left = left[1:]
    }else{
      merged = append(merged, right [0])
      right = right[1:]
    }
  }
  return merged
}
func MergeSort(data [] int) [] int {
  if len(data) <= 1 {
    return data
  }
  mid := len(data)/2
  left := MergeSort(data[:mid])
  right := MergeSort(data[mid:])
  return Merge(left,right)
}
func main(){
  data := [] int{9,4,3,6,1,2,10,5,7,8}
  fmt.Printf("%v\n%v\n", data, MergeSort(data))
}
```

**Решение**

```
package main
import "fmt"
func Merge(left, right [] int) [] int{
  merged := make([] int, 0, len(left) + len(right))
  for len(left) > 0 || len(right) > 0{
    if len(left) == 0 {
      return append(merged,right...)
    }else if len(right) == 0 {
      return append(merged,left...)
    }else if left[0] < right[0] {
      merged = append(merged, left[0])
      left = left[1:]
    }else{
      merged = append(merged, right [0])
      right = right[1:]
    }
  }
  return merged
}
func MergeSort(data [] int) [] int {
  if len(data) <= 1 {
    return data
  }
  done := make(chan bool)
  mid := len(data)/2
  var left [] int
  go func(){
    left = MergeSort(data[:mid])
    done <- true
  }()
  right := MergeSort(data[mid:])
  <-done
  return Merge(left,right)
}
func main(){
  data := [] int{9,4,3,6,1,2,10,5,7,8}
  fmt.Printf("%v\n%v\n", data, MergeSort(data))
}
```

В начале при сортировке слиянием мы рекурсивно разделяем массив на `right` и `left` стороны и **на строках 30-34** вызываем `MergeSort` для обеих сторон.

Теперь нужно сделать так, чтобы `Merge(left, right)` выполнялась после получения возвращаемых значений от обоих рекурсивных вызовов, то есть и `left` и `right` должны обновляться до того, как `Merge(left, right)` сможет быть выполнена. Для этого **на строке 26** мы вводим канал типа `bool` и отправляем в него `true` сразу после выполнения `left = MergeSort(data[:mid]` (**строка 32**).

Операция `<-done` блокирует код **на строке 35** до инструкции `Merge(left,right)`, чтобы она не продолжилась, пока горутина не завершится. После завершения горутины и получения `true` в канале `done` код переходит к инструкции `Merge(left, right)` **на строке 36**.

#### 25. Сумма квадратов

Реализуйте функцию `SumOfSquares`, получающую целое число `c` и возвращающую сумму всех квадратов между 1 и `c`. Вам потребуется использовать инструкции `select`, горутины и каналы.

Например, ввод `5` приведет к возвращению `55`, потому что `$1² + 2² + 3² + 4² + 5² = 55$`.

В качестве отправной точки можно взять этот код:

```
package main
import "fmt"
func SumOfSquares(c, quit chan int) {
// ваш код
}
func main() {
  mychannel := make(chan int)
  quitchannel:= make(chan int)
  sum:= 0
  go func() {
    for i := 0; i < 6; i++ {
      sum += <-mychannel
    }
    fmt.Println(sum)
  }()
  SumOfSquares(mychannel, quitchannel)
}
```

**Решение**

```
package main
import "fmt"
func SumOfSquares(c, quit chan int) {
  y := 1
  for {
    select {
    case c <- (y*y):
      y++
    case <-quit:
      return
    }
  }
}
func main() {
  mychannel := make(chan int)
  quitchannel:= make(chan int)
  sum:= 0
  go func() {
    for i := 1; i <= 5; i++ {
      sum += <-mychannel
    }
    fmt.Println(sum)
    quitchannel <- 0
  }()
  SumOfSquares(mychannel, quitchannel)
}
```

Рассмотрим функцию `SumOfSquares`. Сначала на **строке 4** мы объявляем переменную `y`, после чего переходим к циклу `For-Select`. В инструкциях `select` прописано два кейса.

- `case c <- (y*y)`: служит для отправки квадрата `y` по каналу `c`, который принимается в горутине, созданной в основной рутине.
- `case <-quit`: служит для получения сообщения из основной рутины, которое вернется из функции.



### Задачи по программированию на Go

#### 16. Реализуйте стек (LIFO)

Реализуйте структуру стека с функциональностью `pop`, `append` и `print top`.

**Решение**

Стек можно реализовать с помощью объекта среза.

```
package main
import "fmt"
func main() {
// Создание стека
var stack []string
// Добавление элементов
stack = append(stack, "world!")
stack = append(stack, "Hello ")
for len(stack) > 0 {
        // Print top
        n := len(stack) - 1
        fmt.Print(stack[n])
        // Pop
        stack = stack[:n]
}
// Output: Hello world!
}
```

Сначала мы используем встроенную функцию `append()` для реализации поведения присоединения. Далее с помощью `len(stack)-1` мы извлекаем верхушку стека и выводим ее на экран.

Для `pop` мы устанавливаем в качестве новой длины стека позицию выведенного верхнего значения, `len(stack)-1`.

#### 17. Выведите все пермутации символов среза или строки

Реализуйте функцию `perm()`, принимающую срез или строку и выводящую все возможные комбинации его (ее) символов.

**Решение**

```
package main
import "fmt"
// Perm вызвает f с каждой пермутацией a.
func Perm(a []rune, f func([]rune)) {
        perm(a, f, 0)
}
// Пермутируем значения в индексе i на len(a)-1.
func perm(a []rune, f func([]rune), i int) {
        if i > len(a) {
                f(a)
                return
        }
        perm(a, f, i+1)
        for j := i + 1; j < len(a); j++ {
                a[i], a[j] = a[j], a[i]
                perm(a, f, i+1)
                a[i], a[j] = a[j], a[i]
        }
}
func main() {
Perm([]rune("abc"), func(a []rune) {
        fmt.Println(string(a))
})
}
```

Мы используем типы `rune` для обработки и срезов, и строк. `Runes` являются кодовыми точками из Unicode, а значит могут парсить строки и срезы одинаково.

#### 18. Поменяйте местами значения переменных без использования промежуточной переменной

Реализуйте `swap()`, обменивающую значения двух переменных, не используя третью переменную.

**Решение**

Во многих других языках над этой задачей придется подумать, в Go же реализовать ее просто.

```
package main
import "fmt"
func main() {
   fmt.Println(swap())
}
func swap() []int {
      a, b := 15, 10
   b, a = a, b
   return []int{a, b}
}
```
Достаточно просто включить инструкцию `b, a = a, b`, на чьи данные будет ссылаться переменная, не взаимодействуя ни с одним из ее значений.

#### 19. Реализуйте поведение min и max

Реализуйте функции `Min(x, y int)` и `Max(x, y int)`, получающие два целых числа и возвращающих меньшее или большее значение соответственно.

**Решение**

По умолчанию Go поддерживает `min` и `max` только для чисел с плавающей запятой, используя для этого `math.min` и `math.max`. Вам потребуется создать собственные реализации, чтобы то же самое можно было проделать для целых чисел.

```
package main
import "fmt"
// Min возвращает меньшее из x или y.
func Min(x, y int) int {
        if x > y {
                return y
        }
        return x
}
// Max возвращает большее из x или y.
func Max(x, y int) int {
        if x < y {
                return y
        }
        return x
}
func main() { 
    fmt.Println(Min(5,10))
    fmt.Println(Max(5,10))
}
```

#### 20. Переверните порядок элементов в срезе

Реализуйте функцию `reverse`, получающую срез целых чисел и разворачивающую его без использования временного среза.

**Решение**

```
package main
import "fmt"
func reverse(sw []int) {
        for a, b := 0, len(sw)-1; a < b; a, b = a+1, b-1 {
                sw[a], sw[b] = sw[b], sw[a]
        } 
}
func main() { 
    x := []int{3, 2, 1} 
    reverse(x)
    fmt.Println(x)
}
```

Цикл `for` меняет местами значения каждого элемента среза. Значения будут следовать слева направо, и в итоге все элементы будут развернуты.

#### 21. Как легче всего проверить срез на пустоту?

Создайте программу, проверяющую срез на пустоту. Найдите самое простое решение.

**Решение**

Легче всего проверить срез на пустоту с помощью встроенной функции `len()`, которая возвращает длину среза. Если `len(slice) == 0`, значит срез пуст.

Например:

```
package main
import "fmt"
func main() {
  r := [3]int{1, 2, 3}
  if len(r) == 0 {
    fmt.Println("Empty!")
  } else {
    fmt.Println("Not Empty!")
  }
}
```

#### 22. Отформатируйте строку без ее вывода

Найдите самый простой способ отформатировать строку с переменными, не выводя значение. 

**Решение**

Легче всего это сделать с помощью `fmt.Sprintf()`, которая возвращает строку, не выводя ее на экран.

Например:

```
package main

import "fmt"

func main() {
  s := fmt.Sprintf("Size: %d MB.", 85)
  fmt.Println(s)
}
```

### Вопросы, касающиеся конкурентности

#### 23. Объясните разницу между конкурентностью и параллельностью в Go

Конкурентность  —  это, когда программа может работать с несколькими задачами одновременно, а параллельность  —  это, когда программа может одновременно выполнять несколько задач на нескольких процессорах.

Другими словами, конкурентность  —  это свойство программы, которое позволяет нескольким задачам быть запущенными одновременно, но не обязательно одновременно выполняться. Параллельность же относится к свойствам среды выполнения, когда две или более задач выполняются одновременно.

Это значит, что посредством параллельности можно получить конкурентное поведение, но на этом ее возможности не ограничиваются.

Основными инструментами для реализации конкурентности в Go являются горутины и каналы. Горутины  —  это конкурентные легковесные потоки, а каналы позволяют им взаимодействовать в процессе выполнения.

#### 24. Merge sort 

Реализуйте конкурентное решение `merge sort` (сортировка слиянием), используя горутины и каналы.

В качестве опорной точки можно взять эту последовательную реализацию:

```
package main
import "fmt"
func Merge(left, right [] int) [] int{
  merged := make([] int, 0, len(left) + len(right))
  for len(left) > 0 || len(right) > 0{
    if len(left) == 0 {
      return append(merged,right...)
    }else if len(right) == 0 {
      return append(merged,left...)
    }else if left[0] < right[0] {
      merged = append(merged, left[0])
      left = left[1:]
    }else{
      merged = append(merged, right [0])
      right = right[1:]
    }
  }
  return merged
}
func MergeSort(data [] int) [] int {
  if len(data) <= 1 {
    return data
  }
  mid := len(data)/2
  left := MergeSort(data[:mid])
  right := MergeSort(data[mid:])
  return Merge(left,right)
}
func main(){
  data := [] int{9,4,3,6,1,2,10,5,7,8}
  fmt.Printf("%v\n%v\n", data, MergeSort(data))
}
```

**Решение**

```
package main
import "fmt"
func Merge(left, right [] int) [] int{
  merged := make([] int, 0, len(left) + len(right))
  for len(left) > 0 || len(right) > 0{
    if len(left) == 0 {
      return append(merged,right...)
    }else if len(right) == 0 {
      return append(merged,left...)
    }else if left[0] < right[0] {
      merged = append(merged, left[0])
      left = left[1:]
    }else{
      merged = append(merged, right [0])
      right = right[1:]
    }
  }
  return merged
}
func MergeSort(data [] int) [] int {
  if len(data) <= 1 {
    return data
  }
  done := make(chan bool)
  mid := len(data)/2
  var left [] int
  go func(){
    left = MergeSort(data[:mid])
    done <- true
  }()
  right := MergeSort(data[mid:])
  <-done
  return Merge(left,right)
}
func main(){
  data := [] int{9,4,3,6,1,2,10,5,7,8}
  fmt.Printf("%v\n%v\n", data, MergeSort(data))
}
```

В начале при сортировке слиянием мы рекурсивно разделяем массив на `right` и `left` стороны и **на строках 30-34** вызываем `MergeSort` для обеих сторон.

Теперь нужно сделать так, чтобы `Merge(left, right)` выполнялась после получения возвращаемых значений от обоих рекурсивных вызовов, то есть и `left` и `right` должны обновляться до того, как `Merge(left, right)` сможет быть выполнена. Для этого **на строке 26** мы вводим канал типа `bool` и отправляем в него `true` сразу после выполнения `left = MergeSort(data[:mid]` (**строка 32**).

Операция `<-done` блокирует код **на строке 35** до инструкции `Merge(left,right)`, чтобы она не продолжилась, пока горутина не завершится. После завершения горутины и получения `true` в канале `done` код переходит к инструкции `Merge(left, right)` **на строке 36**.

#### 25. Сумма квадратов

Реализуйте функцию `SumOfSquares`, получающую целое число `c` и возвращающую сумму всех квадратов между 1 и `c`. Вам потребуется использовать инструкции `select`, горутины и каналы.

Например, ввод `5` приведет к возвращению `55`, потому что `$1² + 2² + 3² + 4² + 5² = 55$`.

В качестве отправной точки можно взять этот код:

```
package main
import "fmt"
func SumOfSquares(c, quit chan int) {
// ваш код
}
func main() {
  mychannel := make(chan int)
  quitchannel:= make(chan int)
  sum:= 0
  go func() {
    for i := 0; i < 6; i++ {
      sum += <-mychannel
    }
    fmt.Println(sum)
  }()
  SumOfSquares(mychannel, quitchannel)
}
```

**Решение**

```
package main
import "fmt"
func SumOfSquares(c, quit chan int) {
  y := 1
  for {
    select {
    case c <- (y*y):
      y++
    case <-quit:
      return
    }
  }
}
func main() {
  mychannel := make(chan int)
  quitchannel:= make(chan int)
  sum:= 0
  go func() {
    for i := 1; i <= 5; i++ {
      sum += <-mychannel
    }
    fmt.Println(sum)
    quitchannel <- 0
  }()
  SumOfSquares(mychannel, quitchannel)
}
```

Рассмотрим функцию `SumOfSquares`. Сначала на **строке 4** мы объявляем переменную `y`, после чего переходим к циклу `For-Select`. В инструкциях `select` прописано два кейса.

- `case c <- (y*y)`: служит для отправки квадрата `y` по каналу `c`, который принимается в горутине, созданной в основной рутине.
- `case <-quit`: служит для получения сообщения из основной рутины, которое вернется из функции.