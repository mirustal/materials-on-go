	1. Что такое строка?  
    Ответ:  
    Это неизменяемый срез байтов, также это структура с двумя полями, с указателем на первый елемент и его длина  
    
2. Итерация по строке (выберет любое имя из находящихся), что будет если мы итерируюемся по имени с русскими, и одну букву по ошибке сделали английской, какими будут индексы?  
    Ответ:  
    На примере имя «Павел», где буква «а» английская:  
    Первая итерация – 0  
    Вторая итерация – 2  
    Третья итерация – 3  
    Четвертая итерация - 5  
    
3. Как мы понимаем, какая перед нами буква (англ. или рус.)?  
    Ответ:  
    По кодировке, также в первом бите заложена информация  
    
4. Делаем слайс аппенд, и выходим за его пределы, как рассчитывается во сколько раз увеличить размер слайса?  
    Ответ:  
    Если слайс меньше, чем 256 байт, то умножаем на 2, если больше, то по формуле. Берем длину  
    Заходим в аппенд  
    Создаем новую переменную новый_капасити = старый*2

Проверяем новый_капасити на 256

Если меньше, то используем двойную капасити

Если больше, то рассчитываем капасити по формуле (длина + 3*256)/4

В памяти создается новый массив длиной капасити, в который копируется всё из старого

Возвращаем новый слайс, в котором длина = длина, капасити = новый капасити и указатель на новый участок в памяти  

1. Что происходит, когда мы создали новый слайс?  
    Ответ:  
    Аппенд создаёт новый срез, и в старом слайсе мы не заменяем указатель на массив.  Мы не заменяем указатель на новый массив, который создался  
    
2. Как мы передаём параметры в функции?  
    Ответ:  
    По значению и указателю, по значению передаётся копия, по указателю передаётся адрес памяти.  
      
    
3. Стековый фрейм, что это?  
    Ответ:  
    Это фрейм в стеке, в котором хранятся наши функции  
      
    
4. Размер стекового фрейма всегда один?  
    Ответ:  
    Не фиксированный, зависит от того сколько у нас функций, стековый фрейм создаёт рантайм, создаётся в момент вызова (на этапе вызова, в прологе)  
      
    
5. Максимальный размер стека?  
    Ответ:  
    1гб – х64 система  
    250мб – х32 система  
      
    
6. 10)Кто расширяет стек?  
    Ответ:  
    Его увеличивает рантайм, по формуле  
    
7. 11)Когда уменьшается стек и кем?  
    Ответ:  
    Его уменьшает рантайм, когда заполнено 25-50% стека, когда горутины остановлены  
    
8. 12)Кто чистит кучу?  
    Ответ:  
    GC, после разметки, получили размер живой кучу (черный цвет), прибавили размер стека, умножить на GOGC, получим хиптаргетсайз, и при достижении данное размера, сработает GC, срабатывает раз в 2 минуты, можно и руками, но не стоит  
    
9. 13)GOMEMLIMIT, что это?  
    Ответ:  
    Это параметр, при достижении которого сработает GC, но параметр не строгий, и может чуть-чуть пойти наверх, дабы наша прога не упала  
    
10. 14)Интерфейс, что это?  
    Ответ:  
    Это контракт, и также это структура с двумя полями:  
    tab *itab, и data unsafe.Poniter.  
    
11. 15)Какова длина указателя?  
    Ответ:  
    8 байт – х64  
    4 байта – х32  
    
12. 16)Как хранятся методы в интерфейсе?  
    Ответ:  
    Есть поле func, где uintptr, это массив с 1 елементом, где хранится адрес таблицы с методами, хранятся они как хэши. Сложность приведение интерфейсов — это линейная сложность  
    
13. 17) Что возвращает запись в закрытый канал?  
    Ответ:  
    panic’у о том, что нельзя писать в закрытый канал  
    
14. 18)Что возвращает чтение в закрытый канал?  
    Ответ:  
    Нулевое значение, в зависимости от типа канала  
    
15. 19)Запись в не инициализированный канал, что вернет?  
    Ответ:  
    Deadlock  
    
16. 20)Чтение в не инициализированный канал, что вернет?  
    Ответ:  
    Deadlock  
    
17. 21)Есть RWMutex, 10 пришло прочитать, 1 записать, 10 прочитать, как прочитают первые 10?  
    Ответ:  
    Параллельно, а запись будет идти последовательно, первые 10 пришли, все параллельно читают, потом один пришёл, записывает, потом остальные 10 читают  
      
    
18. 22)Что такое парралелизм?  
    Ответ:  
    Параллелизм – это способность систем управлять n-ое кол-во процессами одновременно. Ограничено кол-вом ядер
19. 23)Что такое конкурентность?  
    Ответ:  
    Это способность программы конкурировать за ресурсы, когда потоков меньше, чем кол-во претендентов  
    
20. 24)Каике есть типы конкурентности?  
    Ответ:  
    Вытесняющая и кооперативная  
    
21. 25)Вытесняющая, это какая?  
    Ответ:  
    Система распределяет равное время для каждого потока, и когда время закончилось, функция закончила.  
    
22. 26)Кооперативная, это какая?  
    Ответ:

Сколько времени требуется, столько времени и будет выполняться функция  

1. 27)Как передаются потоки в кооперативности?  
    Ответ:  
    За этим следит планировщик, горутина отработала, сказал об этом, и планировщик сделал своё дело, а в вытесняющей планировщик приходит сам, и насильно снимает горутину и передаёт его другой горутине  
    
2. 28)Какая в гошке кооперативности?  
    Ответ:  
    Неявная вытесняющая, ибо елементов кооперативности меньше, 90% времени горутинами рулит планировщик. Есть таймслот(10 мс) в течении которого работает горутина, а после 10мс приходит планировщик, то ставит горутину на паузу  
    
3. 29)Как планировщик снимает горутину?  
    Ответ:  
    Ставит их на паузу, перед этим убедившись, что горутина находится в сейф поинте  
    
4. 30)Кто расставляет сейф поинты?  
    Ответ:  
    Компилятор, а планировщик смотрит, где эти сейф поинтеры

  

1. 31)Какие абстракции у планировщика?  
    Ответ:  
    GMP, где G – Это горутины, где M – это OS Thread, где P – лог. процессор.  
    
2. 32)Когда запускается программа, какое кол-во процессоров создаётся?  
    Ответ:  
    Столько, сколько указано в гомакспроц (по умолчанию кол-во ядер на проце)  
    
3. 33)Всегда ли кол-во машин == кол-во процессоров?  
    Ответ:  
    Нет, не всегда  
    
4. 34)Синхронные вызовы, это как?  
    Ответ:  
    Горутина пришла, делает синхронный вызов, запись файл, через 10мс приходит планировщик, видит что это синк.вызов.  
    Планировщик смотрит в пулле тредов, есть ли свободный тред, потом если нет, запрашивает новый, если есть, то тред с синк.вызовом открепляется, и выполняется отдельно, а на место старого треда, приходит новый  
    
5. 35)Асинхронные вызовы, это как?  
    Ответ:  
    Это операция, связанная с походом в сеть.  
    В связку машины-процессора-локальной очереди попадает горутина с асин.вызовом, планировщик спустя 10мс приходит и видит, данный запрос асинхронный, и перемещает горутину в net poller, он обращается к epoll’у (на каждой ОС свой), в net poller она ждёт ответа по сети, в цикле гоняется и опрашивается. И epoll опрашивает таблицу файловых дескриптеров ОС, на предмет получения данных из сети.  
    Модель оси:  
    1) физический уровень (уровень сигнала)

2) Канальный уровень (появляются MAC-адреса)  
3) Сетевой уровень (IP-адреса)  
4) Транспортный уровень (TCP/UDP)  
У нас появляется порт, сокет, и байты/биты записываются в сокет (это просто файл для ОС),  и вот в net poller’e гоняется, опрашивает epoll, epoll смотрит таблицу файловых дескриптеров, на предмет полученных новых байтов, с помощью флага определяется, пришли ли новые данные или нет.  
Затем, горутина получив данные, она с net poller’a попадает в глобальную очередь, потом попадает на локальную, затем попадает на машину, и уже на машине, эта горутина вычитывает данные из сокета, а это уже обычная синхронная операция…

  

  

  

1. 36)Сколько тиков занимает переключения треда?  
    Ответ:  
    1000 тактов, если горутины, то 40-50



## API-интерфейсы Rutime [](https://www.kelche.co/blog/go/golang-scheduling/#rutime-apis)

Среда выполнения go предоставляет несколько API, которые можно использовать для управления планировщиком. Я бы рекомендовал вам не использовать эти API, если в этом нет необходимости. Вот эти API-интерфейсы:

- `runtime.NumGoroutine()` - Возвращает количество горутин, которые выполняются в данный момент.
- `runtime.GOMAXPROCS()` - Устанавливает максимальное количество процессоров, которые могут использоваться средой выполнения go. Следует иметь в виду, что если вы измените значение GOMAXPROCS во время работы программы, это приведет к **остановке мировой** операции. Это связано с тем, что среда выполнения должна будет изменить размер массива, содержащего процессоры, перед возобновлением программы.`GOMAXPROCS`
- `runtime.Gosched()` - Это приведет к тому, что текущая горутина уступит процессору. Вызывающая горутина будет добавлена в глобальную очередь выполнения.
- `runtime.Goexit()` - Это приведет к завершению текущей горутины. Это не повлияет на другие горутины.
- `runtime.LockOSThread()` / `runtime.UnlockOSThread()` - Они свяжут горутину с нижележащим потоком ядра. В основном он используется, когда горутина изменяет состояние потока ядра в той или иной форме