Изучи что такое стрингбилдер 
(нужен для эффективного добавления в строку)

Изучи про  SBO

Для анализа ошибок 
логи, метрики, посмотреть последние деплои, откладка, трейсы

ч
### Интерфейсы

Абстрактные типы данные
Хранить типа объекта и конкретную информацию о типе объекта 

Проверка типа интерфейса можно сделать через тайпСерч, рефлексия 

Типы у которых не может существовать собственных значений 
К примеру числа
Над любыми( с исключениями) совершать арифметические действия, можно объявить абстрактный тип "число", разными реализациями которого будет натуральные, целые, рациональные числа..

Интерфейс это абстрактный тип данных

Идиоматика: 

1. Чем меньше методов тем лучше
2. Если у интерфейса один метод то принято называть интерфейс существительным

пустой интерфейс - это интерфейс, которому соотвествует все что угодно (обязательно нужно обработать все типы данные, которые планируешь поддерживать)


### Хэш-таблица
Преобразуем ключ с помощью хэш функции на выходе получаем число(то есть айдишник нашей ассоциативной таблицы) 

Коллизия - это случай когда после преобразования мы получаем точно такой же ID
	1. Метод открытой адресации - сохранение в следующую свободную ячейку
	2. Пробирование - использование хэш функции к полученному значению до момента пока не появится свободного значнеия 
	3. Метод цепочек - создание списка в ячейке 

Хорошая хэш функция
1) Детерминизм 
2) Равномерность
3) Эфективность должна быть константное
4) Ограниченность 0 < значения после хэш функции < размер таблицы

Как работает мапа в ГО
Абстрактная структурная  данных

### Структура мапы в GO
Мапа состоит из header, который хранит общую инфу
Header:
	1.размер - количество элементов, 
	2. количество бакетов( хранится в логарифме в целях экономии)
	3. Указатель на  бакеты LOB (low order bts)
	4. хэш сид  
Указатель на бакеты: после хэширования ключа происходит побитовое вычисления остатка от деления (то есть число в бинарном виде по количество бакетов логарифма )

Как выглядят бакеты: 
8 слотов для HOB hash,  если ключ есть в текущем бакете то мы берием все ключи с искомым, если его нет то значения точно нет в текущей мапе
Key: ключ
value:   значение

Переполнение бакета создаетс новый бакет, в изначальный бакет  добавилась ссылка на новый бакет 
(эвакуация данных?)

Перебор мапы происходит случайно
В fmt происходит сортировка мапы 

Map insert, remove, lookup
Все операции должны иметь константное время


ВСТАВКА В НЕ ИНИЦИАЛИЗИРОВАННУЮ МАПУ ЭТО ПАНИКА!!!!


### Каналы в го
Каналы хранятся в куче 
	Канал представляет собой структуру которая содержи
	1. количество в буфере 
	2. ссылка на буфер 
	3. указатели на спящие записи/чтнение горутины
	4. Мьютекс

У не буферризированного канала нет буфера и данные с одного стека передается в стек другой 

каналы безопасны за счет мьютексов (и анатомиках)

Каналы Хранят данные в буфере(кольцеризированном)

Передачи данных 

Блокировка горутин. - очереди 

- Запись и чтения с неициализированного канала блокирует горутину!!
- запись в закрытый канал возывает панику
- чтение из закрытого канала дает нулевое значение

### Планировщик GO


Структура планировщика:
Есть

Планировщик работает на потоках ОС, контекст постоянно переключается так чтобы ни один поток не простаивал

Многозадачность 
	1. Кооперативная - если горутина выполняется то она " подсказывает" когда ее можно снять
	2.Вытесняющая - сам решает, когда его можно вытеснуть


Приоритетное планирование, выдавать каким то потокам приоритеты 
### Горутина 
Аналог корутины  


Отличие от обычного потока - это легковесность
У горутины динамический стек и она менеджментся рантаймом го 

## sync.Pool 
Реализация паттерна обжект пул и хранит в себе фиксированное количество объектов (ну куче)
## sync.Cond
Реакция на какое-то действие
### Мьютексы  
Просто какая то атомик операция которою можно проверит, горутина ставится в ожидание и ждет очереди на мьютекс

### Спинлок 
Бесконечный цикл, можно использовать когда мы точно знаем, что не будет никаких систем локов и точно знаем, что из него можем выйти

### Проблемы сихронизации

Data race - Одновременное изменение одного места памяти разными потоками (нужно примитивы синхрнизации)
Есть флаг при компиляции --race (race detector), он никогда не ошибается

dead lock - все горутины заблокированы 


### Атомарные операции
compare 
swap


### Контекст

Интерфейс в котором есть методы которые позволяют отслеживать закрытие или записать значение

Есть пустые контесты

Есть  отмены при вызове контекста, канал закрывает и все получают сигнал об этом

withTimeod - через сколько умрет

withTimeLock- кодка умрет

### ООП В ГО
Классические постулаты 
Полимофирзм - реализовано через интерфейс, все те кто могут говорить, они будут говорить


Наследование - его нет, но можно заменить композицией(Встраивание структуры в структуру)
Инкапсуляция  маленькая/большая буква в GO 






