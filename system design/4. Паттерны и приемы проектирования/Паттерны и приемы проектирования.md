
# Паттерны и проектирования

## Виды деплоя приложения
### Rolling Release
![[rolling-release.png]]
Есть старое приложение, поднимаем новое и пускаем пользователей одновременно на все постепенно отключая старые
### Blue/Green Release
![[blue-green-release.png]]
Всегда есть blue/green инсталяции, при выходе новых версий мы выпускаем ее на green инсталяции и заменяем router на green инсталяцию 
### Canary Release
![[canary-Release.png]]

Понемногу переносится трафик на новые версии 

## Виды паттернов приложений
### MVP(minimal-view-product)
![[mvp-pattern.png]]

### Трехзвенная архитектура
(фронт это просто слой)
![[three-link-pattern.png]]

### Толстый клиент
Получение логики (к примеру профилирования) на frontend
![[fat-client.png]]

### pub / sub 

![[pub-sub-pattern.png]]

### Heart bit
![[heart-bit-pattern.png]]
- посылаем heart bit на client, если он не ответил пару раз, значит он не онлайн

### Service Discovery

![[Service-discovery.png]]

Сервис service-discovery оповещает balancer в случае падения/добавления нового backend

### CQRS

![[CQRS-patterns.png]]
- разделение запросов чтения и записи

### Retries

![[retry.png]]
- Повторяем запросы множество раз
Компромисы:
- пользовательский запрос - расшибись, но ответь
- лучше ответить ошибкой, чем перегрузкой сервисов
- при неидемпотентных запросах нельзя повторять определенные типы запросов

#### Идемпотентность - свойство объекта или операции(GET, PUT, DELETE) при повторном применении операции к объекту давать тот результат, что и при первом 
![[idempotent.png]]

#### backoff - делать retry через интервал времени
![[backoff.png]]

#### backpressure - если пропускная способность меньше чем количество вопросов, можем ratelimit или увеличивать время на вопрос
![[backpressure.png]]

#### Circuit Breaker  пропускаем только % какого-то лимита
![[Circuit breaker.png]]

### Graceful degradation - если сервис чувстует себя плохо, отключается только его неработающая часть сохраняя CORE составляющей

![[Graceful Degradation.png]]

#### fallback - глупый dummy сервер, который будет отвечать в случае поломки основного сервиса
![[fallback.png]]

### Polling - front переспрашивает с какой-то переодичностью
![[polling.png]]

### Long polling - сервер тоже ждет polling, если кто-то еще прислал - отвечает, если никто дополнительно не опросил он отсылает данные 
![[longpolling.png]]

### Streaming - сервер отсылает события по какому-то event
![[stream.png]]

### Map Reduce разбиваем на чатнки
![[map-reduce.png]]

## Микросервисная архитектура
### Агрегатор - сервис берет информацию со всех сервисов и соединяет ее
![[agregator.png]]

### Цепочка - сервис получает информацию у другого сервиса и отдает ее
![[chain.png]]
## Событийно - ориентированная архитектура
### Event Notification
![[event-notification.png]]

1. Обрабатываем запрос
2. Отпускаем клиента
3. Используем события

### State transfer
![[state-transfer.png]]
1. Обрабатываем запрос
2. Отпускаем клиента
3. Используем события
4. Реплицируем данные
### Event collaboration(шина)
![[event-collaboration.png]]
- используется шина для коммуникации между сервисами 

# Консенсус

## Распределенные транзакции
### Двухфазная транзакция (2PC) - получение подвержщдения от двух баз данных
![[2PC.png]]
### Saga - представляет набор локальных транзакций, каждая локальная транзакция обновляет базу данных и публикует сообщение или событие
![[saga.png]]
### Transaction outbox
![[transaction-outbox.png]]

### Распределенные блокировки
#### Положить в кэш с особым ключем
#### Выбор лидера - лидер постоянно обновляет аренду на доступ к системе (испольузется lis id)
![[leader.png]]

##### Алгоритм забияки -
##### Raft и Paxos -
# Установка требований к системе
## функциональные требования - заявление о том, как должна вести себя системы | Например: фичи, которыми пользуется пользователь

## нефункциональные требования - требования, определяющие свойства, которые система должна демонстрировать, или ограничения, которая она должна соблюдать | например: производительность, надежность
# Расчет нагрузки на систему